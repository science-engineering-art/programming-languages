\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\babel@aux[2]{}
\@nameuse{bbl@beforestart}
\catcode `"\active 
\catcode `<\active 
\catcode `>\active 
\@nameuse{es@quoting}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\babel@aux{spanish}{}
\@writefile{toc}{\contentsline {section}{\tocsection {}{1}{Definici\'on de las clases genéricas linked\_list y node}}{1}{section.1}\protected@file@percent }
\newlabel{lst:listing-cpp}{{1}{1}{Sample Code Listing C++}{lstlisting.1}{}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {1}Sample Code Listing C++}{1}{lstlisting.1}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\tocsection {}{2}{Definici\'on de miembros de datos necesarios de ambas clases}}{2}{section.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{2.1}{Nuevos elementos introducidos a partir de C++11 que permiten un manejo más "inteligente" de la memoria}}{2}{subsection.2.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{2.2}{Inicializaci\'on}}{2}{subsection.2.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{2.3}{Filosofía en el uso de la memoria defendida por C++}}{2}{subsection.2.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{2.4}{Simplificaci\'on de nombres de tipos mediante el uso de alias}}{2}{subsection.2.4}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\tocsection {}{3}{Definici\'on de los constructores clásicos de C++(C++0x) , el constructor move y las sobrecargas del operador =}}{3}{section.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{3.1}{¿Qué hace cada uno de ellos? ¿Cuándo se llaman?}}{3}{subsection.3.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{3.2}{¿Qué es un lvalue y un rvalue ?}}{3}{subsection.3.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{3.3}{std::move}}{3}{subsection.3.3}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\tocsection {}{4}{Definici\'on de un constructor que permita hacer list-initialization lo más parecido a C\# posible}}{4}{section.4}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.1}{Compare la utilización del \{\} v.s ()}}{4}{subsection.4.1}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\tocsection {}{5}{Definici\'on de un constructor que reciba un vector $ <T> $}}{5}{section.5}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{5.1}{Usar for\_each con expresiones lambda}}{5}{subsection.5.1}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\tocsection {}{6}{Definici\'on del destructor de la clase}}{6}{section.6}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{6.1}{¿Hace falta?}}{6}{subsection.6.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{6.2}{¿Para qué casos haría falta un puntero crudo (raw pointer)?}}{6}{subsection.6.2}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\tocsection {}{7}{Definici\'on de las funciones length , Add\_Last , Remove\_Last , At , Remove\_Ate}}{7}{section.7}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{7.1}{Noexcept}}{7}{subsection.7.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{7.2}{Inferencia de tipo en C++ (auto, decltype decltype(auto)). Explicar todos, pero no obligatoriamente usarlos.}}{7}{subsection.7.2}\protected@file@percent }
\newlabel{tocindent-1}{0pt}
\newlabel{tocindent0}{0pt}
\newlabel{tocindent1}{17.77782pt}
\newlabel{tocindent2}{29.38873pt}
\newlabel{tocindent3}{0pt}
\@writefile{toc}{\contentsline {section}{\tocsection {}{8}{Crear un puntero a función Function<R, T...> que devuelve un valor de tipo R y recibe un número variable de parámetros de tipo T .}}{8}{section.8}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{8.1}{Definir una función genérica Map a linked\_list en T y R , que recibe un puntero a función que transforma un elemento T en uno R; de manera que Map devuelve una instancia de linked\_list$ < $R$ > $ resultado de aplicar a todos los elementos T de la lista original la función de transformación.}}{8}{subsection.8.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{8.2}{Crear punteros a funciones usando alias }}{8}{subsection.8.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{8.3}{Crear un puntero a función Function que permita cualquier cantidad de parámetros de cualquier tipo.}}{8}{subsection.8.3}\protected@file@percent }
\gdef \@abspage@last{10}
