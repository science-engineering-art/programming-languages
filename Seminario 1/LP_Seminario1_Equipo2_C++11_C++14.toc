\babel@toc {spanish}{}
\contentsline {section}{\numberline {1}Definici\'on de las clases genéricas linked\_list y node}{1}{section.1}%
\contentsline {section}{\numberline {2}Definici\'on de miembros de datos necesarios de ambas clases}{1}{section.2}%
\contentsline {subsection}{\numberline {2.1}Nuevos elementos introducidos a partir de C++11 que permiten un manejo más "inteligente" de la memoria}{1}{subsection.2.1}%
\contentsline {subsection}{\numberline {2.2}Inicializaci\'on}{1}{subsection.2.2}%
\contentsline {subsection}{\numberline {2.3}Filosofía en el uso de la memoria defendida por C++}{3}{subsection.2.3}%
\contentsline {subsection}{\numberline {2.4}Simplificaci\'on de nombres de tipos mediante el uso de alias}{3}{subsection.2.4}%
\contentsline {section}{\numberline {3}Definici\'on de los constructores clásicos de C++(C++0x) , el constructor move y las sobrecargas del operador =}{3}{section.3}%
\contentsline {subsection}{\numberline {3.1}¿Qué hace cada uno de ellos? ¿Cuándo se llaman?}{3}{subsection.3.1}%
\contentsline {subsection}{\numberline {3.2}¿Qué es un lvalue y un rvalue ?}{3}{subsection.3.2}%
\contentsline {subsection}{\numberline {3.3}std::move}{3}{subsection.3.3}%
\contentsline {section}{\numberline {4}Definici\'on de un constructor que permita hacer list-initialization lo más parecido a C\# posible}{4}{section.4}%
\contentsline {subsection}{\numberline {4.1}Compare la utilización del \{\} v.s ()}{4}{subsection.4.1}%
\contentsline {section}{\numberline {5}Definici\'on de un constructor que reciba un vector $ <T> $}{5}{section.5}%
\contentsline {subsection}{\numberline {5.1}Usar for\_each con expresiones lambda}{5}{subsection.5.1}%
\contentsline {section}{\numberline {6}Definici\'on del destructor de la clase}{6}{section.6}%
\contentsline {subsection}{\numberline {6.1}¿Hace falta?}{6}{subsection.6.1}%
\contentsline {subsection}{\numberline {6.2}¿Para qué casos haría falta un raw pointer?}{6}{subsection.6.2}%
\contentsline {section}{\numberline {7}Definici\'on de las funciones length , Add\_Last , Remove\_Last , At , Remove\_Ate}{7}{section.7}%
\contentsline {subsection}{\numberline {7.1}Noexcept}{7}{subsection.7.1}%
\contentsline {subsection}{\numberline {7.2}Inferencia de tipo en C++ (auto, decltype decltype(auto)). Explicar todos, pero no obligatoriamente usarlos.}{7}{subsection.7.2}%
\contentsline {section}{\numberline {8}Crear un puntero a función Function<R, T...> que devuelve un valor de tipo R y recibe un número variable de parámetros de tipo T .}{8}{section.8}%
\contentsline {subsection}{\numberline {8.1}Definir una función genérica Map a linked\_list en T y R , que recibe un puntero a función que transforma un elemento T en uno R; de manera que Map devuelve una instancia de linked\_list$ < $R$ > $ resultado de aplicar a todos los elementos T de la lista original la función de transformación.}{8}{subsection.8.1}%
\contentsline {subsection}{\numberline {8.2}Crear punteros a funciones usando alias }{8}{subsection.8.2}%
\contentsline {subsection}{\numberline {8.3}Crear un puntero a función Function que permita cualquier cantidad de parámetros de cualquier tipo.}{8}{subsection.8.3}%
