\babel@toc {spanish}{}
\contentsline {section}{\numberline {1}Definici\'on de las clases genéricas linked\_list y node}{1}{section.1}%
\contentsline {section}{\numberline {2}Definici\'on de miembros de datos necesarios de ambas clases}{1}{section.2}%
\contentsline {subsection}{\numberline {2.1}Nuevos elementos introducidos a partir de C++11 que permiten un manejo más ``inteligente" de la memoria}{1}{subsection.2.1}%
\contentsline {subsection}{\numberline {2.2}Inicializaci\'on}{1}{subsection.2.2}%
\contentsline {subsection}{\numberline {2.3}Filosofía en el uso de la memoria defendida por C++}{3}{subsection.2.3}%
\contentsline {subsection}{\numberline {2.4}Simplificaci\'on de nombres de tipos mediante el uso de alias}{3}{subsection.2.4}%
\contentsline {section}{\numberline {3}Definici\'on de los constructores clásicos de C++(C++0x) , el constructor move y las sobrecargas del operador =}{3}{section.3}%
\contentsline {subsection}{\numberline {3.1}¿Qué es un lvalue y un rvalue?}{3}{subsection.3.1}%
\contentsline {subsection}{\numberline {3.2}Constructores}{4}{subsection.3.2}%
\contentsline {subsection}{\numberline {3.3}Sobrecargas}{4}{subsection.3.3}%
\contentsline {subsection}{\numberline {3.4}La funci\'on std::move}{5}{subsection.3.4}%
\contentsline {section}{\numberline {4}Definici\'on de un constructor que permita hacer list-initialization lo más parecido a C\# posible}{5}{section.4}%
\contentsline {subsection}{\numberline {4.1}Compare la utilización del \{\} v.s ()}{5}{subsection.4.1}%
\contentsline {section}{\numberline {5}Definici\'on de un constructor que reciba un vector $ <T> $}{5}{section.5}%
\contentsline {subsection}{\numberline {5.1}Usar for\_each con expresiones lambda}{5}{subsection.5.1}%
\contentsline {section}{\numberline {6}Definici\'on del destructor de la clase}{5}{section.6}%
\contentsline {subsection}{\numberline {6.1}¿Hace falta?}{6}{subsection.6.1}%
\contentsline {subsection}{\numberline {6.2}¿Para qué casos haría falta un raw pointer?}{6}{subsection.6.2}%
\contentsline {section}{\numberline {7}Definici\'on de las funciones $ length $, $ Add\_Last $ , $ Remove\_Last $, $ At $, $ Remove\_At $}{6}{section.7}%
\contentsline {subsection}{\numberline {7.1}Noexcept}{6}{subsection.7.1}%
\contentsline {subsection}{\numberline {7.2}Inferencia de tipo en C++ (auto, decltype decltype(auto)). Explicar todos, pero no obligatoriamente usarlos.}{6}{subsection.7.2}%
\contentsline {section}{\numberline {8}Crear un puntero a función $ Function<R, T...> $ que devuelve un valor de tipo $ R $ y recibe un número variable de parámetros de tipo $ T $ .}{7}{section.8}%
\contentsline {subsection}{\numberline {8.1}Definir una función genérica Map a linked\_list en T y R , que recibe un puntero a función que transforma un elemento T en uno R; de manera que Map devuelve una instancia de linked\_list$ < $R$ > $ resultado de aplicar a todos los elementos T de la lista original la función de transformación.}{7}{subsection.8.1}%
\contentsline {subsection}{\numberline {8.2}Crear punteros a funciones usando alias }{7}{subsection.8.2}%
\contentsline {subsection}{\numberline {8.3}Crear un puntero a función Function que permita cualquier cantidad de parámetros de cualquier tipo.}{7}{subsection.8.3}%
