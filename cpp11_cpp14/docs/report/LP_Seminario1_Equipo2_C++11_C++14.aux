\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\babel@aux[2]{}
\@nameuse{bbl@beforestart}
\catcode `"\active 
\catcode `<\active 
\catcode `>\active 
\@nameuse{es@quoting}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\babel@aux{spanish}{}
\@writefile{toc}{\contentsline {section}{\numberline {1}Definici\'on de las clases genéricas linked\_list y node}{1}{section.1}\protected@file@percent }
\newlabel{lst:listing-cpp}{{1}{1}{}{lstlisting.-1}{}}
\@writefile{lol}{\contentsline {lstlisting}{1\textendash 2.cpp}{1}{lstlisting.-1}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2}Definici\'on de miembros de datos necesarios de ambas clases}{2}{section.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Nuevos elementos introducidos a partir de C++11 que permiten un manejo más ``inteligente" de la memoria}{2}{subsection.2.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Inicializaci\'on}{2}{subsection.2.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Filosofía en el uso de la memoria defendida por C++}{3}{subsection.2.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Simplificaci\'on de nombres de tipos mediante el uso de alias}{4}{subsection.2.4}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {3}Definici\'on de los constructores clásicos de C++(C++0x) , el constructor move y las sobrecargas del operador =}{4}{section.3}\protected@file@percent }
\newlabel{lst:listing-cpp}{{3}{4}{}{lstlisting.-2}{}}
\@writefile{lol}{\contentsline {lstlisting}{3.cpp}{4}{lstlisting.-2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}¿Qué es un lvalue y un rvalue?}{5}{subsection.3.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}Constructores}{5}{subsection.3.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3}Sobrecargas}{6}{subsection.3.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.4}La funci\'on std::move}{6}{subsection.3.4}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {4}Definici\'on de un constructor que permita hacer list-initialization lo más parecido a C\# posible}{7}{section.4}\protected@file@percent }
\newlabel{lst:listing-cpp}{{4}{7}{}{lstlisting.-3}{}}
\@writefile{lol}{\contentsline {lstlisting}{4.cpp}{7}{lstlisting.-3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Compare la utilización del \{\} v.s ()}{7}{subsection.4.1}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {5}Definici\'on de un constructor que reciba un vector $ <T> $}{7}{section.5}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1}Usar for\_each con expresiones lambda}{7}{subsection.5.1}\protected@file@percent }
\newlabel{lst:listing-cpp}{{5.1}{7}{}{lstlisting.-4}{}}
\@writefile{lol}{\contentsline {lstlisting}{5.cpp}{7}{lstlisting.-4}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {6}Definici\'on del destructor de la clase}{8}{section.6}\protected@file@percent }
\newlabel{lst:listing-cpp}{{6}{8}{}{lstlisting.-5}{}}
\@writefile{lol}{\contentsline {lstlisting}{6.cpp}{8}{lstlisting.-5}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1}¿Hace falta?}{8}{subsection.6.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2}¿Para qué casos haría falta un raw pointer?}{8}{subsection.6.2}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {7}Definici\'on de las funciones $ length $, $ Add\_Last $ , $ Remove\_Last $, $ At $, $ Remove\_At $}{8}{section.7}\protected@file@percent }
\newlabel{lst:listing-cpp}{{7}{8}{}{lstlisting.-6}{}}
\@writefile{lol}{\contentsline {lstlisting}{7.cpp}{8}{lstlisting.-6}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {7.1}Noexcept}{10}{subsection.7.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2}Inferencia de tipo en C++ (auto, decltype decltype(auto))}{10}{subsection.7.2}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {8}Crear un puntero a función $ Function<R, T...> $ que devuelve un valor de tipo $ R $ y recibe un número variable de parámetros de tipo $ T $ .}{11}{section.8}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {8.1}Definir una función genérica Map a linked\_list en T y R , que recibe un puntero a función que transforma un elemento T en uno R; de manera que Map devuelve una instancia de linked\_list $ <R> $ resultado de aplicar a todos los elementos T de la lista original la función de transformación.}{11}{subsection.8.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {8.2}Crear punteros a funciones usando alias }{11}{subsection.8.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {8.3}Crear un puntero a función Function que permita cualquier cantidad de parámetros de cualquier tipo.}{11}{subsection.8.3}\protected@file@percent }
\newlabel{lst:listing-cpp}{{8.3}{11}{}{lstlisting.-7}{}}
\@writefile{lol}{\contentsline {lstlisting}{8.cpp}{11}{lstlisting.-7}\protected@file@percent }
\gdef \@abspage@last{13}
